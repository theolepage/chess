#pragma once

#include <optional>

#include "color.hh"
#include "piece-type.hh"
#include "position.hh"
#include "parsing/pgn_parser/report-type.hh"

namespace board
{
    class Move final
    {
    public:
        using opt_piece_t = std::optional<PieceType>;

        Move(const Position& start,
             const Position& end,
             const PieceType& piece,
             const bool capture,
             const bool double_pawn_push,
             const bool queen_castling,
             const bool king_castling,
             const bool en_passant,
             const opt_piece_t& promotion = std::nullopt);

        bool operator==(const Move& move) const;
        bool operator!=(const Move& move) const;

        const Position& start_get(void) const;
        const Position& end_get(void) const;
        PieceType piece_get(void) const;
        bool capture_get(void) const;
        bool double_pawn_push_get(void) const;
        bool queen_castling_get() const;
        bool king_castling_get() const;
        bool castling_get() const;
        bool en_passant_get() const;
        const opt_piece_t& promotion_get() const;
        void set(const Position &start,
                 const Position &end,
                 const PieceType &piece,
                 const bool capture,
                 const bool double_pawn_push,
                 const bool queen_castling,
                 const bool king_castling,
                 const bool en_passant,
                 const opt_piece_t &promotion);
        Move get_reverse(void) const // Reverse start and end, doesn't compile if placed in hxx
        {
            return Move(end_, start_, piece_, capture_, double_pawn_push_, queen_castling_, king_castling_, en_passant_, promotion_);
        }

        friend std::ostream& operator<<(std::ostream& os, const Position& pos);

    private:
        // The original position of the piece
        Position start_;

        // The destination of the piece
        Position end_;

        // The type of the moving piece
        PieceType piece_;

        // If promotion, contains the piecetype generated by the promotion
        opt_piece_t promotion_;

        // If the move is a capture
        bool capture_;

        // If the move is a double pawn push
        bool double_pawn_push_;

        // If the move is a queen castling
        bool queen_castling_;

        // If the move is a king castling
        bool king_castling_;

        // If the move is an en passant
        bool en_passant_;
    };
} // namespace board

#include "move.hxx"
