#pragma once

#include <optional>

#include "color.hh"
#include "piece-type.hh"
#include "position.hh"
#include "parsing/pgn_parser/report-type.hh"

namespace board
{
    class Move final
    {
    public:
        using opt_piece_t = std::optional<PieceType>;

        Move(const Position& start,
             const Position& end,
             const PieceType& piece,
             const bool capture,
             const bool double_pawn_push,
             const bool queen_castling,
             const bool king_castling,
             const bool en_passant,
             const opt_piece_t& promotion = std::nullopt);

        bool operator==(const Move& move) const;
        bool operator!=(const Move& move) const;

        const Position& start_get(void) const;
        const Position& end_get(void) const;
        PieceType piece_get(void) const;
        bool capture_get(void) const;
        bool double_pawn_push_get(void) const;
        bool queen_castling_get(void) const;
        bool king_castling_get(void) const;
        bool castling_get(void) const;
        bool en_passant_get(void) const;
        const opt_piece_t& promotion_get(void) const;
        Move get_reverse(void) const // Reverse start and end, doesn't compile if placed in hxx
        {
            return Move(end_, start_, piece_, capture_, double_pawn_push_, queen_castling_, king_castling_, en_passant_, promotion_);
        }

    private:
        // The original position of the piece
        const Position start_;

        // The destination of the piece
        const Position end_;

        // The type of the moving piece
        const PieceType piece_;

        // If promotion, contains the piecetype generated by the promotion
        const opt_piece_t promotion_;

        // If the move is a capture
        const bool capture_;

        // If the move is a double pawn push
        const bool double_pawn_push_;

        // If the move is a queen castling
        const bool queen_castling_;

        // If the move is a king castling
        const bool king_castling_;

        // If the move is an en passant
        const bool en_passant_;
    };
} // namespace board

#include "move.hxx"
